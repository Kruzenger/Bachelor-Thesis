\section{Определение требований и компонентов}
\label{sec:Chapter3} \index{Chapter3}
    На основе проведённого анализа существущих технологий и архитектур, к системе были вынесены следующие функциональные и нефункциональные требования:
    \subsection{Требования к системе}
        \subsubsection{Функциональные требования}
            Система должна обеспечивать выполнение следующих функциональных задач:
            \begin{enumerate}
                \item Система обеспечивает непрерывный прием данных, генерируемых пользователями. В качестве источника используются сообщества социальной сети ВКонтанте (VK) 
                \item Система обеспечивает обработку каждого поста (сообщения) с задержкой, не превышающей установленный порог (менее 60 секунд) от момента публикации в VK до завершения его обработки в рамках основного конвейера.
                \item Система обеспечивает асинхронную, надежную и упорядоченную (в рамках партиций) передачу данных между микросервисами, ответственными за различные этапы обработки. Маршрутизация осуществляется через систему обработки событий, выступающую в качестве шины событий. Планируется использование Apache Kafka.
                \item Система обеспечивает сохранение результатов обработки каждого поста в промежуточном хранилище с возможностью последующего извлечения для дальнейшего анализа и агрегации. Данные сохраняются в структурированном виде, пригодном для эффективного выполнения аналитических запросов.
                \item Система обеспечит эффективный полнотекстовый поиск и сложный аналитический запрос по историческим данным, накопленным в результате работы. Планируется использование Elasticsearch для поиска и, возможно, Cassandra (или аналогичной распределенной NoSQL БД) для хранения детализированных данных, оптимизированных под высокую скорость записи и масштабируемость.
            \end{enumerate}

        \subsubsection{Нефункциональные требования}
            Система должна обладать следующими качественными характеристиками:
            \begin{enumerate}
                \item Система гарантирует обработку более 90\% поступающих постов с задержкой менее 60 секунд от момента появления поста в VK до завершения его базовой обработки (FR2). Это требование является основным критерием "реального времени" в рамках данной работы. Система также должна обеспечивать пропускную способность, достаточную для обработки пиковой нагрузки, характерной для выбранных для мониторинга популярных пабликов VK.
                \item Система проектируется с расчетом на горизонтальную масштабируемость. Увеличение объема обрабатываемых данных (числа отслеживаемых пабликов/постов) должно достигаться преимущественно за счет добавления вычислительных ресурсов (нод) и параллельных экземпляров микросервисов без изменения архитектуры. Компаненты системы должны уметь масштабироваться независимо друг от друга.
                \item Система проектируется с расчётом на удобство интеграций сторонних сервисов и добавления нового функционала. Нарпимер добавление новой социальной сети к обработке, нового типа данных, внедрение машинного обучения или добавление новых сообществ и целей к обработке.
            \end{enumerate}

    \subsection{Выбор компонентов}
        \subsubsection{Выбор языка программирования}
            При проектировании системы потоковой обработки данных социальных сетей одним из аспектов является выбор языка программирования, способного обеспечить баланс между производительностью, гибкостью интеграции и скоростью разработки. В качестве потенциальных кандидатов рассматриваются языки с различными парадигмами, включая C++, Java, Go и Python. Каждый из них обладает уникальными характеристиками, однако окончательный выбор должен учитывать специфику задач, связанных с агрегацией данных, взаимодействием с внешними API (например, VK API) и интеграцией с распределёнными системами (Apache Kafka, Flink). Исходя из этих критериев был выбран Python. \\

            \textbf{Критерии выбора}
            \begin{enumerate}
                \item \textbf{Интеграционная гибкость} — поддержка библиотек для работы с разнородными сервисами и протоколами.
                \item \textbf{Скорость разработки} — лаконичность синтаксиса и доступность инструментов для быстрого прототипирования.
                \item \textbf{Производительность} — эффективность выполнения ресурсоёмких операций, таких как обработка потоков данных.
                \item \textbf{Экосистема} — наличие готовых решений для машинного обучения, многопоточности, визуализации, интеграции распределённых систем и работы с Big Data.
            \end{enumerate}
            
            Paссмотрим альтернативы и варианты. В качестве возможных языков были выбраны следующие: \textbf{C++}, \textbf{Java}, \textbf{Go}, \textbf{Python}. Проанализируем их сильные и слабые стороны с учётом заданных критериев. \\

            \textbf{Анализ альтернатив}
            \begin{enumerate}
                \item \textbf{C++} демонстрирует высокую производительность за счёт низкоуровневого управления памятью и оптимизированной компиляции. Это делает его предпочтительным для задач, требующих минимальных задержек. Однако для интеграции с современными облачными сервисами и RESTful API необходима разработка дополнительных обёрток, что увеличивает сроки реализации. Кроме того, отсутствие встроенной поддержки асинхронных операций усложняет работу с потоковыми данными.
                \item \textbf{Java} предлагает развитую экосистему (Spring, Apache Camel) и высокую портируемость за счёт JVM. Тем не менее, строгая статическая типизация и объёмный boilerplate-код замедляют итеративную разработку, что критично для динамично меняющихся требований социальных сетей.
                \item \textbf{Go} выделяется простотой создания многопоточных приложений, но ограниченная поддержка библиотек для интеграции с NLP-фреймворками или аналитическими инструментами снижает его применимость в данном контексте.
                \item \textbf{Python} предлагает высокую скорость разработки за счёт простоты языка и наличия большого числа готовых решений из различных отраслей. Так же Python предлагает широкий выбор специализированных библиотек, для интеграции разнородных сервисов. 
            \end{enumerate}
            
            \textbf{Обоснование выбора: Python} 

            Выбор Python в качестве основного языка для реализации платформы обусловлен необходимостью быстрой интеграции с разнородными сервисами, доступностью специализированных библиотек и снижением временных затрат на разработку. Несмотря на компромиссы в производительности, его экосистема предоставляет инструменты для построения масштабируемых и maintainable-решений, соответствующих требованиям современных социальных медиа. \\

            Python, несмотря на более низкую производительность в сравнении с компилируемыми языками, становится оптимальным решением благодаря следующим факторам:
            \begin{enumerate}
                \item \textbf{Богатая экосистема библиотек:}
                \begin{itemize}
                    \item \textbf{Интеграция с API} — Библиотеки requests, aiohttp, vkbottle и vk-api упрощают взаимодействие с социальными сетями (VK, Telegram) и внешними сервисами.
                    \item \textbf{Работа с потоковыми данными} — Kafka-python, pyflink и faust обеспечивают совместимость с Apache Kafka и Flink, позволяя реализовывать сложные ETL-процессы.
                    \item \textbf{Аналитика и ML} — Pandas, NumPy, scikit-learn и TensorFlow поддерживают обработку данных и внедрение моделей машинного обучения. Это может быть полезно при дальнейшем разширении и развитии.
                \end{itemize}

                \item \textbf{Асинхронная обработка:} \\
                Модуль asyncio и фреймворки (FastAPI, Quart) позволяют эффективно управлять тысячами одновременных подключений, что критично для систем агрегации данных в реальном времени.

                \item \textbf{Скорость разработки:} \\
                Динамическая типизация и лаконичный синтаксис сокращают время написания кода. Простота эксплуатации и запуска значительно упрощают тестирование гипотез.

                \item \textbf{Сообщество и документация:} \\
                Широкая популярность Python гарантирует доступ к актуальным руководствам, форумам и open-source проектам, что минимизирует риски возникновения неразрешимых проблем.

                \item \textbf{Гибкость масштабирования:} \\
                Для оптимизации производительности критических участков кода возможно использование C-расширений (Cython) или интеграция с высокопроизводительными фреймворками (Dask, Ray).
            \end{enumerate}

        \subsubsection{Интеграция с VK API}
            Интеграция с API социальной сети ВКонтакте (VK) является критически важным компонентом платформы, обеспечивающим сбор данных, управление контентом и взаимодействие с пользователями. При выборе библиотеки для работы с VK API необходимо учитывать такие факторы, как поддержка асинхронных операций, удобство работы с методами API, качество документации и совместимость с архитектурой системы. Среди доступных решений (например, vk\_api, aiovk, vkbottle) анализ функциональности и производительности позволил определить оптимальный вариант — фреймворк vkbottle. \\

            \textbf{Критерии выбора}
            \begin{enumerate}
                \item \textbf{Асинхронная обработка запросов} — минимизация задержек при работе с сетевыми операциями.
                \item \textbf{Поддержка Long Poll API} — эффективный механизм для получения событий в реальном времени из источников, к которым имеются права администрации.
                \item \textbf{Гибкость архитектуры} — возможность кастомизации обработчиков и middleware.
                \item \textbf{Совместимость с экосистемой Python} — интеграция с asyncio и другими библиотеками.
            \end{enumerate}

            Paссмотрим альтернативы и варианты. В качестве возможных библиотек были выбраны следующие: \textbf{vk\_api}, \textbf{vkbottle}, \textbf{aiovk}. Проанализируем их сильные и слабые стороны с учётом заданных критериев. \\

            \textbf{Анализ альтернатив}
            \begin{enumerate}
                \item \textbf{vk\_api} — Широко используемая библиотека, предоставляющая базовый функционал для работы с API. Однако отсутствие нативной поддержки асинхронности делает её непригодной для высоконагруженных систем, где параллельная обработка тысяч запросов является обязательным требованием.
                \item \textbf{vkbottle} — Распространённая всинхронная библиотека. Имеет широкий функционал и подробную документацию. Поддерживает кастомизацию процессов, для более тонкой настройки.
                \item \textbf{aiovk} — Библиотека с асинхронным подходом, основанная на aiohttp. Несмотря на улучшенную производительность, её функционал ограничен базовыми методами API, а документация недостаточно детализирована для сложных сценариев.
            \end{enumerate}
            
            \textbf{Обоснование выбора vkbottle}

            Выбор vkbottle в качестве основы для взаимодействия с VK API обусловлен его способностью эффективно решать задачи асинхронной обработки событий, сохраняя высокую производительность в условиях интенсивной нагрузки. Это согласуется с общей архитектурой платформы, где ключевыми требованиями являются масштабируемость, минимальные задержки и интеграция с распределёнными системами. Использование данной библиотеки не только оптимизирует работу с API, но и обеспечивает основу для будущего расширения функционала, такого как внедрение чат-ботов или автоматизированных служб поддержки. Его архитектура предоставляет следующие преимущества:
            \begin{enumerate}
                \item \textbf{Асинхронная модель выполнения} — Использование asyncio позволяет обрабатывать множество запросов параллельно без блокировки основного потока. Это особенно важно для социальных сетей, где задержки в получении данных (например, комментариев или лайков) могут привести к потере актуальности информации. Благодаря неблокирующим операциям, vkbottle эффективно использует ресурсы, что нивелирует ограничения Python, связанные с глобальной блокировкой интерпретатора (GIL).
                \item \textbf{Модульность и расширяемость} — vkbottle поддерживает множественные запросы, в том числе с использованием более чем одного ключа, что позволяет оптимизировать процессы. Так же vkbottle поддерживает создание кастомных middleware, что позволяет внедрять дополнительную логику (например, логирование, кеширование, валидацию) на разных этапах обработки запросов. Интеграция с DI-контейнерами (Dependency Injection) упрощает управление зависимостями в крупных проектах.
                \item \textbf{Совместимость с аналитическими инструментами} — Библиотека легко интегрируется с другими . Это обеспечивает беспрепятственное взаимодействие с Apache Kafka (через kafka-python) и Apache Flink, что критично для сквозной обработки данных.
            \end{enumerate}

            Использование vkbottle позволяет избежать узких мест, характерных для синхронных подходов. Например, при одновременной обработке входящих сообщений от тысяч пользователей асинхронная модель обеспечивает линейное масштабирование производительности без увеличения задержек. Кроме того, фреймворк поддерживает автоматическое повторение неудачных запросов и обработку квот API, что повышает отказоустойчивость системы.
            
        \subsubsection{Выбор системы обработки событий}
            Для реализации потоковой обработки данных социальных сетей критически важен выбор технологической платформы, обеспечивающей масштабируемость, отказоустойчивость и низкую задержку. Рассмотрим основные системы, релевантные для решения поставленной задачи, и выделим из анализа, проведённого в предыдущей главе, все ключевые особенности. \\

            \textbf{Критерии выбора}
            \begin{enumerate}
                \item \textbf{Гарантии доставки} — обеспечение семантики "ровно один раз" для исключения дублирования и потерь данных при сбоях, что принципиально важно для точности аналитических отчётов.
                \item \textbf{Задержка обработки} — максимально допустимое время между поступлением события и получением результата его обработки, определяющее возможность работы в режиме реального времени.
                \item \textbf{Пропускная способность} — способность системы обрабатывать пиковые нагрузки, характерные для социальных сетей, измеряемая в событиях/секунду при сохранении стабильной задержки.
                \item \textbf{Управление состоянием} — возможности эффективного хранения и восстановления контекста обработки (агрегаторов, сессий пользователей) при горизонтальном масштабировании и отказах узлов.
                \item \textbf{Горизонтальная масштабируемость} — автоматическое распределение нагрузки между узлами, перебалансировка партиций без прерывания обслуживания и обработка асимметрии нагрузки.
                \item \textbf{Операционная устойчивость} — встроенные механизмы восстановления после сбоев, мониторинг сквозной задержки (end-to-end latency) и интеграция с системами алертинга.
            \end{enumerate}

            \textbf{Apache Kafka}

            Apache Kafka представляет собой распределённую платформу для потоковой передачи данных, функционирующую как высокопроизводительный брокер сообщений. Её архитектура основана на модели публикации-подписки с разделением данных на тематические каналы (топики), каждый из которых делится на партиции для обеспечения параллелизма. Уникальной особенностью Kafka является комбинация характеристик: 
            \begin{itemize}
                \item Гарантированная пропускная способность на уровне миллионов сообщений в секунду
                \item Минимальные задержки доставки (менее 10 мс)
                \item Механизм репликации данных для отказоустойчивости
                \item Долговременное хранение сообщений с настраиваемой политикой
            \end{itemize}

            Важным аспектом является поддержка семантики \textit{"ровно один раз"} через транзакционные продюсеры, что исключает дублирование или потерю данных. Для аналитических задач Kafka предоставляет библиотеку Kafka Streams и движок ksqlDB, позволяющий выполнять SQL-запросы над потоками в реальном времени. \\

            \textbf{Apache Flink}

            Apache Flink является фреймворком для распределённой обработки потоковых и пакетных данных с акцентом на низкую задержку и точные семантики. Его архитектурное отличие от аналогов заключается в нативной реализации потоковой модели (true streaming), где данные обрабатываются по мере поступления, а не разбиваются на микропакеты. Ключевые особенности включают:
            \begin{itemize}
                \item Поддержка обработки по времени событий (event-time processing)
                \item Распределённые снапшоты состояния (distributed snapshots)
                \item Точную семантику \textit{"ровно один раз"} без снижения производительности
                \item Интеграцию с комплексной обработкой событий (CEP)
            \end{itemize}

            Flink демонстрирует особую эффективность для сценариев, требующих сложных агрегаций в скользящих окнах или поддержки состояний в терабайтном диапазоне, что актуально для анализа социальных взаимодействий. \\

            \textbf{Apache Storm}

            Apache Storm относится к раннему поколению систем реального времени, обеспечивающему экстремально низкие задержки обработки (менее 5 мс). Его модель основана на направленных ациклических графах (DAG), где вершинами являются спауты (источники данных) и болты (обработчики). Storm оптимизирован для задач простой трансформации и маршрутизации потоков, но имеет ограничения в управлении состоянием и обработке временных меток. Для достижения семантики \textit{"ровно один раз"} требуется использование надстройки Trident, что снижает производительность системы. \\

            \textbf{Spark Streaming}

            Spark Streaming реализует микропакетную модель обработки данных, преобразуя входящие потоки в последовательность RDD-датасетов (Resilient Distributed Datasets). Главным преимуществом данного подхода является унификация API для пакетной и потоковой обработки, позволяющая использовать единую кодовую базу для ETL-задач. Система обеспечивает:
            \begin{itemize}
                \item Интеграцию с экосистемой Spark (MLlib, GraphX)
                \item Гарантии \textit{"ровно один раз"} через механизм чекпоинтов
                \item Поддержку обработки по времени событий
            \end{itemize}
            
            Ограничением Spark Streaming является повышенная задержка (от 500 мс до 2 с), обусловленная природой микропакетов. \\

            \textbf{RabbitMQ}

            RabbitMQ представляет собой традиционный брокер сообщений, реализующий протокол AMQP. В отличие от систем потоковой обработки, его фокус смещён в сторону гарантированной доставки и гибкой маршрутизации между очередями. Ключевые характеристики:
            \begin{itemize}
                \item Поддержка сложных схем маршрутизации (direct, topic, headers)
                \item Механизмы подтверждения доставки (acknowledgements)
                \item Интерфейсы управления очередями и сообщениями
            \end{itemize}

            Для задач аналитики в реальном времени RabbitMQ менее применим из-за отсутствия встроенных механизмов оконной агрегации и ограниченной пропускной способности по сравнению с Kafka. \\

            \textbf{Обоснование выбора}

            Для разрабатываемой системы анализа данных социальных сетей выбор пал на комбинацию Apache Kafka и Apache Flink. Kafka обеспечивает надёжную буферизацию входящих потоков из VK API с гарантией сохранности данных, в то время как Flink предоставляет необходимые инструменты для сложной агрегации и анализа с соблюдением требования к задержке $<60$ секунд. Данная архитектура позволяет реализовать гибридную модель Каппа-архитектуры смешанной с микросервисной архитектурой, где единый поток данных обслуживает как реальную аналитику, так и пакетную обработку через реплей событий.

            \begin{table}[h]
                \centering
                \caption{Сравнительные характеристики систем обработки событий}
                \label{tab:streaming-comparison}
                \begin{tabular}{|l|c|c|c|c|}
                    \hline
                    Система & Тип. задержка & Гарантии доставки & Управление состоянием \\
                    \hline
                    Apache Kafka & $<10$ мс & "ровно один раз" & Ограниченное \\
                    \hline
                    Apache Flink & $50$ мс & "ровно один раз" & Продвинутое \\
                    \hline
                    Apache Storm & $<5$ мс & "минимум один раз" & Базовое \\
                    \hline
                    Spark Streaming & $0.5-2$ с & "ровно один раз" & Продвинутое \\
                    \hline
                    RabbitMQ & $<5$ мс & "максимум один раз" & Отсутствует \\
                    \hline
                \end{tabular}
            \end{table}
\newpage
